<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Math Fractal Engine (Ultimate Edition)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-family: 'Courier New', monospace; font-size: 1.2rem;
            text-transform: uppercase; letter-spacing: 2px; pointer-events: none;
            text-shadow: 0 0 10px #00ffff; transition: opacity 0.5s;
        }
        #ui {
            position: absolute; bottom: 20px; left: 20px;
            color: rgba(255, 255, 255, 0.8); font-family: 'Courier New', monospace;
            font-size: 0.9rem; pointer-events: none; user-select: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .key {
            color: #fff; background: rgba(255,255,255,0.2); 
            padding: 2px 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.4);
        }
    </style>
</head>
<body>
    <div id="loading">Initialising Hyper-Geometry...</div>
    <div id="ui">
        SYSTEM: MATH CORE<br>
        [CLICK] to Warp Surge<br>
        [SPACE] to Change Theme<br>
        [MOUSE] to Scatter Numbers
    </div>

    <!-- Three.js & Post Processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                cyan: 0x00ffff,
                blue: 0x0055ff,
                purple: 0x8a2be2,
                darkMetal: 0x111116,
                glow: 0x00ffff
            }
        };

        const THEMES = [
            { // 0: Cyberpunk (Default)
                name: "CYBERPUNK",
                primary: 0x00ffff, secondary: 0x8a2be2, bg: 0x050510
            },
            { // 1: Matrix
                name: "MATRIX",
                primary: 0x00ff00, secondary: 0x003300, bg: 0x000500
            },
            { // 2: Solar Flare
                name: "SOLAR",
                primary: 0xffaa00, secondary: 0xff4400, bg: 0x100500
            }
        ];

        let currentThemeIdx = 0;

        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let engineGroup = new THREE.Group();
        let coreCrystal;
        let gears = [];
        let squareGears = [];
        let satellites = [];
        let conduits = [];
        let symbols = [];
        let particles;
        let numberSprites = [];
        let starGeo; 
        
        let mouseX = 0, mouseY = 0;
        let rawMouseX = 0, rawMouseY = 0; 
        let targetRotationX = 0, targetRotationY = 0;
        let surgeFactor = 1.0;

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(THEMES[0].bg, 0.02);
            scene.background = new THREE.Color(THEMES[0].bg);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // --- LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const coreLight = new THREE.PointLight(THEMES[0].primary, 2, 50);
            coreLight.position.set(0, 0, 0);
            coreLight.name = "coreLight";
            scene.add(coreLight);

            const secondaryLight = new THREE.PointLight(THEMES[0].secondary, 1.5, 40);
            secondaryLight.position.set(10, 10, 10);
            secondaryLight.name = "secLight";
            scene.add(secondaryLight);

            // --- BUILD ENGINE PARTS ---
            createCore();
            createMainGears();
            createSquareGears(); 
            createSatellites();
            createConduits();
            createFloatingNumbers();
            createEnvironment();

            scene.add(engineGroup);

            // --- POST PROCESSING (BLOOM) ---
            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.8, 0.15
            );

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- EVENTS ---
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('keydown', onKeyDown, false);
            
            // Hide loader
            setTimeout(() => {
                document.getElementById('loading').style.opacity = 0;
            }, 1000);

            animate();
        }

        // --- ASSET GENERATION FUNCTIONS ---

        function createTextTexture(text, size=128, color='#00ffff') {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = `bold ${size*0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size/2, size/2);
            ctx.shadowColor = color;
            ctx.shadowBlur = size * 0.1;
            ctx.strokeText(text, size/2, size/2);
            return new THREE.CanvasTexture(canvas);
        }

        function createCore() {
            const geometry = new THREE.DodecahedronGeometry(3.5, 0);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0x22aaff, emissive: 0x001133, roughness: 0.1, metalness: 0.1,
                transmission: 0.6, transparent: true, opacity: 0.9, side: THREE.DoubleSide
            });
            coreCrystal = new THREE.Mesh(geometry, material);
            engineGroup.add(coreCrystal);

            const edges = new THREE.EdgesGeometry(geometry);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            const wireframe = new THREE.LineSegments(edges, lineMat);
            coreCrystal.add(wireframe);

            const symbolsList = ['+', '−', '×', '÷', '=', '%', 'π', '√', 'x', 'y'];
            const symbolGeo = new THREE.PlaneGeometry(0.8, 0.8);
            
            symbolsList.forEach((char) => {
                const texture = createTextTexture(char);
                const mat = new THREE.MeshBasicMaterial({ 
                    map: texture, transparent: true, side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending, depthWrite: false
                });
                const mesh = new THREE.Mesh(symbolGeo, mat);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 1.5 + Math.random() * 1.0;
                mesh.position.set(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                mesh.lookAt(0,0,0);
                mesh.userData = { rotationSpeed: (Math.random()-0.5)*0.05, initialPos: mesh.position.clone() };
                coreCrystal.add(mesh);
                symbols.push(mesh);
            });
        }

        function createGear(radius, teeth, width, color, speed, isRuler = false) {
            const shape = new THREE.Shape();
            const outerRadius = radius;
            const innerRadius = radius * 0.85;
            const holeRadius = radius * 0.6;
            
            for (let i = 0; i < teeth * 2; i++) {
                const angle = (Math.PI * 2 * i) / (teeth * 2);
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                if (i === 0) shape.moveTo(r * Math.cos(angle), r * Math.sin(angle));
                else shape.lineTo(r * Math.cos(angle), r * Math.sin(angle));
            }
            shape.closePath();
            const holePath = new THREE.Path();
            holePath.absarc(0, 0, holeRadius, 0, Math.PI * 2, true);
            shape.holes.push(holePath);

            const geometry = new THREE.ExtrudeGeometry(shape, { steps: 1, depth: width, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 });
            const material = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.4, emissive: 0x000000 });
            const mesh = new THREE.Mesh(geometry, material);
            
            // Edges at children[0]
            const edgeMat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
            mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), edgeMat));
            
            // Ticks at children[1] (if Ruler)
            if (isRuler) {
                const tickGroup = new THREE.Group();
                const tickGeo = new THREE.BoxGeometry(0.1, 0.4, 0.05);
                const tickMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const rTicks = holeRadius * 1.25;
                for(let t=0; t<36; t++) {
                    const tick = new THREE.Mesh(tickGeo, tickMat);
                    const ang = (t/36)*Math.PI*2;
                    tick.position.set(Math.cos(ang)*rTicks, Math.sin(ang)*rTicks, width/2 + 0.05);
                    tick.rotation.z = ang;
                    tickGroup.add(tick);
                }
                mesh.add(tickGroup);
            }

            const group = new THREE.Group();
            group.add(mesh);
            mesh.position.z = -width / 2;
            group.userData = { rotSpeed: speed, baseColor: color }; 
            return group;
        }

        function createSquareGears() {
            const size = 18;
            const teethPerSide = 5;
            const shape = new THREE.Shape();
            const step = size / teethPerSide;
            
            shape.moveTo(-size/2, -size/2);
            
            const sides = [
                {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 0, y: -1} 
            ];

            let currX = -size/2;
            let currY = -size/2;

            sides.forEach(dir => {
                for(let i=0; i<teethPerSide; i++) {
                    currX += dir.x * (step * 0.6);
                    currY += dir.y * (step * 0.6);
                    shape.lineTo(currX, currY);
                    
                    const tx = -dir.y * 1.5; 
                    const ty = dir.x * 1.5;
                    
                    shape.lineTo(currX + tx, currY + ty);
                    currX += dir.x * (step * 0.4);
                    currY += dir.y * (step * 0.4);
                    shape.lineTo(currX + tx, currY + ty);
                    shape.lineTo(currX, currY);
                }
            });
            
            const holePath = new THREE.Path();
            holePath.moveTo(-size*0.4, -size*0.4);
            holePath.lineTo(size*0.4, -size*0.4);
            holePath.lineTo(size*0.4, size*0.4);
            holePath.lineTo(-size*0.4, size*0.4);
            holePath.closePath();
            shape.holes.push(holePath);

            const geometry = new THREE.ExtrudeGeometry(shape, { steps: 1, depth: 1, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 1 });
            const material = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.4 });
            const mesh = new THREE.Mesh(geometry, material);
            
            const edgeMat = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.5 });
            mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), edgeMat));

            const group = new THREE.Group();
            group.add(mesh);
            mesh.position.z = -0.5;
            group.position.z = -4; 
            
            const g1 = group.clone();
            g1.userData = { rotSpeed: 0.005, baseColor: 0xff00ff };
            engineGroup.add(g1);
            squareGears.push(g1);

            const g2 = group.clone();
            g2.rotation.z = Math.PI / 4;
            g2.scale.set(1.2, 1.2, 1);
            g2.userData = { rotSpeed: -0.003, baseColor: 0x00ffff };
            engineGroup.add(g2);
            squareGears.push(g2);
        }

        function createMainGears() {
            const gear1 = createGear(9, 24, 1.0, CONFIG.colors.blue, 0.002);
            gear1.position.z = -1;
            engineGroup.add(gear1);
            gears.push(gear1);

            const gear2 = createGear(6.5, 18, 0.8, CONFIG.colors.purple, -0.003, true);
            gear2.position.z = 1.5;
            engineGroup.add(gear2);
            gears.push(gear2);

            const gear3 = createGear(4.5, 12, 0.5, CONFIG.colors.cyan, 0.005);
            gear3.position.z = 2.5;
            engineGroup.add(gear3);
            gears.push(gear3);
        }

        function createSatellites() {
            const positions = [{ r: 12, a: 2.6 }, { r: 12, a: -0.8 }, { r: 12, a: -2.5 }];
            const shapes = [
                new THREE.BoxGeometry(1.2, 1.2, 1.2),
                new THREE.TetrahedronGeometry(1.0, 0),
                new THREE.OctahedronGeometry(1.0, 0)
            ];

            positions.forEach((pos, idx) => {
                const orbitGroup = new THREE.Group();
                orbitGroup.rotation.z = pos.a;
                
                const satGear = createGear(2, 10, 0.5, CONFIG.colors.cyan, 0.02);
                satGear.position.x = pos.r;
                satGear.userData.baseColor = CONFIG.colors.cyan; 
                
                const icoGeo = shapes[idx % shapes.length];
                const icoMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.purple, wireframe: true, transparent: true, opacity: 0.8 });
                const ico = new THREE.Mesh(icoGeo, icoMat);
                
                const innerGeo = icoGeo.clone(); innerGeo.scale(0.7,0.7,0.7);
                const icoGlow = new THREE.Mesh(innerGeo, new THREE.MeshBasicMaterial({ color: CONFIG.colors.cyan, transparent: true, opacity: 0.2 }));
                ico.add(icoGlow);
                
                satGear.add(ico);
                satGear.userData.innerIco = ico; 

                orbitGroup.add(satGear);
                engineGroup.add(orbitGroup);
                
                satellites.push({
                    orbit: orbitGroup, gear: satGear,
                    orbitSpeed: (Math.random() * 0.005 + 0.002) * (Math.random() > 0.5 ? 1 : -1)
                });
            });
        }

        function createConduits() {
            for(let i=0; i<5; i++) {
                const angle = (Math.PI * 2 / 5) * i;
                const path = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0), 
                    new THREE.Vector3(Math.cos(angle)*4, Math.sin(angle)*4, 2),
                    new THREE.Vector3(Math.cos(angle+0.5)*12, Math.sin(angle+0.5)*12, 0)
                ]);

                const geometry = new THREE.TubeGeometry(path, 64, 0.15, 8, false);
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0,0,64,0);
                grad.addColorStop(0, '#000000'); grad.addColorStop(0.5, '#00ffff'); grad.addColorStop(1, '#000000');
                ctx.fillStyle = grad; ctx.fillRect(0,0,64,32);

                const mat = new THREE.MeshBasicMaterial({ 
                    map: new THREE.CanvasTexture(canvas), transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
                });
                mat.map.wrapS = THREE.RepeatWrapping;

                const tube = new THREE.Mesh(geometry, mat);
                engineGroup.add(tube);
                conduits.push({ mesh: tube, speed: Math.random() * 0.01 + 0.005 });
            }
        }

        function createFloatingNumbers() {
            const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
            for (let i = 0; i < 50; i++) {
                const num = numbers[Math.floor(Math.random() * numbers.length)];
                const texture = createTextTexture(num, 64, '#ffffff');
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, color: 0x4488ff });
                const sprite = new THREE.Sprite(material);
                
                const r = 15 + Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                sprite.position.set(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                
                sprite.userData = {
                    basePos: sprite.position.clone(),
                    velocity: new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01)
                };
                engineGroup.add(sprite);
                numberSprites.push(sprite);
            }
        }

        function createEnvironment() {
            const count = 1500;
            starGeo = new THREE.BufferGeometry();
            const pos = []; const sizes = [];
            for(let i=0; i<count; i++) {
                const r = 20 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                sizes.push(Math.random() * 0.3);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            starGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            starGeo.userData = { originalPos: pos.slice() };
            
            const tex = createTextTexture('.', 32, '#ffffff');
            particles = new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 0.3, map: tex, transparent: true, opacity: 0.4, color: 0x4488ff, blending: THREE.AdditiveBlending, depthWrite: false }));
            scene.add(particles);
            scene.add(new THREE.GridHelper(60, 60, 0x003344, 0x001122).rotateX(Math.PI/2).translateZ(-10));
        }

        // --- INTERACTION LOGIC ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            rawMouseX = event.clientX;
            rawMouseY = event.clientY;
            mouseX = (event.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (event.clientY - window.innerHeight / 2) * 0.001;
        }

        function onMouseDown() {
            surgeFactor = 5.0;
            const flash = new THREE.PointLight(0xffffff, 5, 100);
            scene.add(flash);
            let intensity = 5;
            const flashInt = setInterval(() => {
                intensity *= 0.8; flash.intensity = intensity;
                if(intensity < 0.1) { scene.remove(flash); clearInterval(flashInt); }
            }, 50);
        }

        function onKeyDown(event) {
            if(event.code === 'Space') {
                currentThemeIdx = (currentThemeIdx + 1) % THEMES.length;
                applyTheme(THEMES[currentThemeIdx]);
            }
        }

        function applyTheme(theme) {
            scene.fog.color.setHex(theme.bg);
            scene.background.setHex(theme.bg);
            
            const coreL = scene.getObjectByName("coreLight");
            if(coreL) coreL.color.setHex(theme.primary);
            const secL = scene.getObjectByName("secLight");
            if(secL) secL.color.setHex(theme.secondary);

            // Update Geometries colors
            gears.forEach(g => {
                const gearMesh = g.children[0];
                if(gearMesh && gearMesh.children.length > 0) {
                    const edge = gearMesh.children[0]; // Edge is 1st child (index 0)
                    if(edge && edge.material) edge.material.color.setHex(theme.primary);
                }
            });
            squareGears.forEach(g => {
                const gearMesh = g.children[0];
                if(gearMesh && gearMesh.children.length > 0) {
                    const edge = gearMesh.children[0]; // Edge is 1st child (index 0)
                    if(edge && edge.material) edge.material.color.setHex(theme.secondary);
                }
            });
            satellites.forEach(s => {
                // s.gear is the Group. children[1] is the Icosahedron Mesh
                const ico = s.gear.children[1];
                if(ico && ico.material) {
                    ico.material.color.setHex(theme.secondary); 
                    if(ico.children[0] && ico.children[0].material) {
                         ico.children[0].material.color.setHex(theme.primary); 
                    }
                }
            });
            
            numberSprites.forEach(s => s.material.color.setHex(theme.primary));
            document.getElementById('ui').innerHTML = `SYSTEM: MATH CORE [${theme.name}]<br>[CLICK] to Surge<br>[SPACE] to Change Theme<br>[MOUSE] to Scatter Numbers`;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            surgeFactor = THREE.MathUtils.lerp(surgeFactor, 1.0, delta * 2.0);

            // Camera Parallax & Shake
            const shake = (surgeFactor - 1) * 0.05;
            targetRotationX = mouseY;
            targetRotationY = mouseX;
            engineGroup.rotation.x += 0.05 * (targetRotationX - engineGroup.rotation.x) + (Math.random()-0.5)*shake;
            engineGroup.rotation.y += 0.05 * (targetRotationY - engineGroup.rotation.y) + (Math.random()-0.5)*shake;
            camera.position.z = 25 + Math.sin(time * 0.5) * 1.0;

            // Core Pulse
            const pulse = (Math.sin(time * 1.5) + 1) * 0.5;
            const theme = THEMES[currentThemeIdx];
            const cColor = new THREE.Color().lerpColors(new THREE.Color(theme.primary), new THREE.Color(theme.secondary), pulse);
            coreCrystal.material.color = cColor;
            coreCrystal.material.emissiveIntensity = 0.5 + pulse * 1.5 * surgeFactor;
            coreCrystal.rotation.y -= 0.005 * surgeFactor;
            coreCrystal.rotation.z += 0.003 * surgeFactor;

            // Symbols
            symbols.forEach(mesh => {
                mesh.rotation.z += mesh.userData.rotationSpeed * surgeFactor;
                mesh.position.y += Math.sin(time + mesh.userData.initialPos.x) * 0.005;
            });

            // Gears
            gears.forEach(gear => gear.rotation.z += gear.userData.rotSpeed * surgeFactor);
            squareGears.forEach(gear => gear.rotation.z += gear.userData.rotSpeed * surgeFactor);

            // Satellites
            satellites.forEach(sat => {
                sat.orbit.rotation.z += sat.orbitSpeed * 0.5 * surgeFactor;
                sat.gear.rotation.z -= 0.03 * surgeFactor;
                sat.gear.userData.innerIco.rotation.x += 0.02 * surgeFactor;
                sat.gear.userData.innerIco.rotation.y += 0.03 * surgeFactor;
            });

            // Conduits
            conduits.forEach(c => c.mesh.material.map.offset.x -= c.speed * surgeFactor);

            // Particles Warp Effect
            const positions = particles.geometry.attributes.position.array;
            const original = particles.geometry.userData.originalPos;
            for(let i=0; i < positions.length; i+=3) {
                if(surgeFactor > 1.1) {
                    positions[i+2] += (surgeFactor * 2); 
                    if(positions[i+2] > 50) positions[i+2] = -50;
                } else {
                    positions[i+2] += (original[i+2] - positions[i+2]) * 0.1;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += 0.001 * surgeFactor;

            // Interactive Number Cloud
            const vector = new THREE.Vector3(
                (rawMouseX / window.innerWidth) * 2 - 1,
                -(rawMouseY / window.innerHeight) * 2 + 1,
                0.5
            );
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const worldMouse = camera.position.clone().add(dir.multiplyScalar(distance));

            numberSprites.forEach(sprite => {
                sprite.position.add(sprite.userData.velocity);
                
                const d = sprite.position.distanceTo(worldMouse);
                if (d < 5) {
                    const repel = sprite.position.clone().sub(worldMouse).normalize().multiplyScalar(0.2);
                    sprite.position.add(repel);
                } else {
                    if(sprite.position.length() > 30) {
                        sprite.position.lerp(sprite.userData.basePos, 0.01);
                    }
                }
                
                sprite.material.opacity = 0.4 + Math.sin(time*2 + sprite.position.x)*0.2;
            });

            composer.render();
        }

        init();

    </script>
</body>
</html>