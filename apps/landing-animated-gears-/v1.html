<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Math Fractal Engine (K-8 Edition)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-family: 'Courier New', monospace; font-size: 1.2rem;
            text-transform: uppercase; letter-spacing: 2px; pointer-events: none;
            text-shadow: 0 0 10px #00ffff; transition: opacity 0.5s;
        }
        #ui {
            position: absolute; bottom: 20px; left: 20px;
            color: rgba(0, 255, 255, 0.7); font-family: 'Courier New', monospace;
            font-size: 0.8rem; pointer-events: none; user-select: none;
        }
    </style>
</head>
<body>
    <div id="loading">Calculating Geometry...</div>
    <div id="ui">SYSTEM: MATH CORE<br>STATUS: CALCULATING<br>[CLICK TO SURGE]</div>

    <!-- Three.js & Post Processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                cyan: 0x00ffff,
                blue: 0x0055ff,
                purple: 0x8a2be2,
                darkMetal: 0x111116,
                glow: 0x00ffff
            },
            speed: 1.0,
            bloomStrength: 1.5,
            bloomRadius: 0.8,
            bloomThreshold: 0.15
        };

        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let engineGroup = new THREE.Group();
        let coreCrystal;
        let gears = [];
        let satellites = [];
        let conduits = [];
        let symbols = [];
        let particles;
        let numberSprites = [];
        
        // Mouse interaction
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let surgeFactor = 1.0;

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.02);
            scene.background = new THREE.Color(0x050510);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // --- LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const coreLight = new THREE.PointLight(CONFIG.colors.cyan, 2, 50);
            coreLight.position.set(0, 0, 0);
            scene.add(coreLight);

            const secondaryLight = new THREE.PointLight(CONFIG.colors.purple, 1.5, 40);
            secondaryLight.position.set(10, 10, 10);
            scene.add(secondaryLight);

            // --- BUILD ENGINE PARTS ---
            createCore();
            createMainGears();
            createSatellites();
            createConduits();
            createFloatingNumbers(); // New: Floating Numbers
            createEnvironment();

            scene.add(engineGroup);

            // --- POST PROCESSING (BLOOM) ---
            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                CONFIG.bloomRadius,
                CONFIG.bloomThreshold
            );

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- EVENTS ---
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            
            // Hide loader
            setTimeout(() => {
                document.getElementById('loading').style.opacity = 0;
            }, 1000);

            animate();
        }

        // --- ASSET GENERATION FUNCTIONS ---

        function createTextTexture(text, size=128, color='#00ffff') {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = `bold ${size*0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size/2, size/2);
            
            // Add glow to text
            ctx.shadowColor = color;
            ctx.shadowBlur = size * 0.1;
            ctx.strokeText(text, size/2, size/2);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createCore() {
            // The Dodecahedron Crystal
            const geometry = new THREE.DodecahedronGeometry(3.5, 0);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0x22aaff,
                emissive: 0x001133,
                roughness: 0.1,
                metalness: 0.1,
                transmission: 0.6, // Glass-like
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            coreCrystal = new THREE.Mesh(geometry, material);
            engineGroup.add(coreCrystal);

            // Wireframe overlay for the crystal
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            const wireframe = new THREE.LineSegments(edges, lineMat);
            coreCrystal.add(wireframe);

            // Inner Floating Symbols - K-8 Standard Math
            const symbolsList = ['+', '−', '×', '÷', '=', '%', 'π', '√', 'x', 'y'];
            const symbolGeo = new THREE.PlaneGeometry(0.8, 0.8);
            
            symbolsList.forEach((char, i) => {
                const texture = createTextTexture(char);
                const mat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const mesh = new THREE.Mesh(symbolGeo, mat);
                // Random position inside crystal
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 1.5 + Math.random() * 1.0;
                
                mesh.position.set(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                mesh.lookAt(0,0,0);
                mesh.userData = { 
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    floatSpeed: Math.random() * 0.02,
                    initialPos: mesh.position.clone()
                };
                
                coreCrystal.add(mesh);
                symbols.push(mesh);
            });
        }

        function createGear(radius, teeth, width, color, speed, isRuler = false) {
            const shape = new THREE.Shape();
            const outerRadius = radius;
            const innerRadius = radius * 0.85;
            const holeRadius = radius * 0.6;
            const numTeeth = teeth;

            // Draw gear shape
            for (let i = 0; i < numTeeth * 2; i++) {
                const angle = (Math.PI * 2 * i) / (numTeeth * 2);
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                if (i === 0) shape.moveTo(r * Math.cos(angle), r * Math.sin(angle));
                else shape.lineTo(r * Math.cos(angle), r * Math.sin(angle));
            }
            shape.closePath();

            // Hole in the middle
            const holePath = new THREE.Path();
            holePath.absarc(0, 0, holeRadius, 0, Math.PI * 2, true);
            shape.holes.push(holePath);

            const extrudeSettings = {
                steps: 1,
                depth: width,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 2
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Dark metal material
            const material = new THREE.MeshStandardMaterial({
                color: 0x111111,
                metalness: 0.8,
                roughness: 0.4,
                emissive: 0x000000
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Add Glowing Edges
            const edgeGeo = new THREE.EdgesGeometry(geometry);
            const edgeMat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
            const edges = new THREE.LineSegments(edgeGeo, edgeMat);
            mesh.add(edges);

            // Add internal details
            const ringGeo = new THREE.TorusGeometry(holeRadius * 1.1, 0.05, 8, 30);
            const ringMat = new THREE.MeshBasicMaterial({ color: color });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.z = width / 2;
            mesh.add(ring);

            // Ruler/Protractor Tick Marks
            if (isRuler) {
                const tickGroup = new THREE.Group();
                const tickGeo = new THREE.BoxGeometry(0.1, 0.4, 0.05);
                const tickMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const rTicks = holeRadius * 1.25;
                for(let t=0; t<36; t++) {
                    const tick = new THREE.Mesh(tickGeo, tickMat);
                    const ang = (t / 36) * Math.PI * 2;
                    tick.position.set(Math.cos(ang)*rTicks, Math.sin(ang)*rTicks, width/2 + 0.05);
                    tick.rotation.z = ang;
                    tickGroup.add(tick);
                }
                mesh.add(tickGroup);
            }

            const group = new THREE.Group();
            group.add(mesh);
            mesh.position.z = -width / 2;
            
            group.userData = { rotSpeed: speed };
            
            return group;
        }

        function createMainGears() {
            // Main backing gear
            const gear1 = createGear(9, 24, 1.0, CONFIG.colors.blue, 0.002);
            gear1.position.z = -1;
            engineGroup.add(gear1);
            gears.push(gear1);

            // Middle ring gear with RULER MARKS
            const gear2 = createGear(6.5, 18, 0.8, CONFIG.colors.purple, -0.003, true);
            gear2.position.z = 1.5;
            engineGroup.add(gear2);
            gears.push(gear2);

            // Front smaller detail gear
            const gear3 = createGear(4.5, 12, 0.5, CONFIG.colors.cyan, 0.005);
            gear3.position.z = 2.5;
            engineGroup.add(gear3);
            gears.push(gear3);
        }

        function createSatellites() {
            const positions = [
                { r: 12, a: 2.6, s: 0.8 }, // ~10 o'clock
                { r: 12, a: -0.8, s: 0.8 }, // ~2 o'clock
                { r: 12, a: -2.5, s: 0.8 }  // ~7 o'clock
            ];

            // DISTINCT SHAPES FOR K-8 GEOMETRY (Cube, Tetrahedron, Octahedron)
            const shapes = [
                new THREE.BoxGeometry(1.2, 1.2, 1.2), // Cube
                new THREE.TetrahedronGeometry(1.0, 0), // Triangular Pyramid
                new THREE.OctahedronGeometry(1.0, 0)   // Octahedron (Diamond)
            ];

            positions.forEach((pos, idx) => {
                const orbitGroup = new THREE.Group();
                orbitGroup.rotation.z = pos.a;
                
                const satGear = createGear(2, 10, 0.5, CONFIG.colors.cyan, 0.02);
                satGear.position.x = pos.r;
                
                // Use a different geometry for each satellite
                const geoIndex = idx % shapes.length;
                const icoGeo = shapes[geoIndex];

                const icoMat = new THREE.MeshBasicMaterial({ 
                    color: CONFIG.colors.purple, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                const ico = new THREE.Mesh(icoGeo, icoMat);
                
                // Solid inner glow core
                const innerGeo = shapes[geoIndex].clone();
                innerGeo.scale(0.7, 0.7, 0.7);
                const icoGlow = new THREE.Mesh(
                    innerGeo,
                    new THREE.MeshBasicMaterial({ color: CONFIG.colors.cyan, transparent: true, opacity: 0.2 })
                );
                ico.add(icoGlow);
                
                satGear.add(ico);
                satGear.userData.innerIco = ico;

                orbitGroup.add(satGear);
                engineGroup.add(orbitGroup);
                
                satellites.push({
                    orbit: orbitGroup,
                    gear: satGear,
                    orbitSpeed: (Math.random() * 0.005 + 0.002) * (Math.random() > 0.5 ? 1 : -1)
                });
            });
        }

        function createConduits() {
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6
            });

            for(let i=0; i<5; i++) {
                const angle = (Math.PI * 2 / 5) * i + Math.random();
                const path = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0), 
                    new THREE.Vector3(Math.cos(angle)*4, Math.sin(angle)*4, 2),
                    new THREE.Vector3(Math.cos(angle + 0.5)*8, Math.sin(angle + 0.5)*8, -1),
                    new THREE.Vector3(Math.cos(angle + 1.0)*12, Math.sin(angle + 1.0)*12, 0),
                ]);

                const geometry = new THREE.TubeGeometry(path, 64, 0.15, 8, false);
                
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createLinearGradient(0,0,64,0);
                grad.addColorStop(0, '#000000');
                grad.addColorStop(0.5, '#00ffff');
                grad.addColorStop(1, '#000000');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,64,32);

                const tex = new THREE.CanvasTexture(canvas);
                tex.wrapS = THREE.RepeatWrapping;
                tex.repeat.set(2, 1);
                
                const mat = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    transparent: true, 
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const tube = new THREE.Mesh(geometry, mat);
                engineGroup.add(tube);
                conduits.push({ mesh: tube, speed: Math.random() * 0.01 + 0.005 });
            }
        }

        // NEW: Floating Numbers Function
        function createFloatingNumbers() {
            const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
            
            for (let i = 0; i < 40; i++) {
                const num = numbers[Math.floor(Math.random() * numbers.length)];
                const texture = createTextTexture(num, 64, '#4488ff');
                
                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true, 
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const sprite = new THREE.Sprite(material);
                
                // Random position in a cloud around the engine
                const r = 10 + Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                sprite.position.set(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                // Scale sprite randomly
                const scale = 1 + Math.random() * 1.5;
                sprite.scale.set(scale, scale, 1);
                
                sprite.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    )
                };

                engineGroup.add(sprite);
                numberSprites.push(sprite);
            }
        }

        function createEnvironment() {
            const count = 1000;
            const geom = new THREE.BufferGeometry();
            const pos = [];
            const sizes = [];
            
            for(let i=0; i<count; i++) {
                const r = 15 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                sizes.push(Math.random() * 0.2);
            }
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geom.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(16, 16, 15, 0, Math.PI*2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            const tex = new THREE.CanvasTexture(canvas);

            const mat = new THREE.PointsMaterial({
                size: 0.3,
                map: tex,
                transparent: true,
                opacity: 0.4,
                color: 0x4488ff,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geom, mat);
            scene.add(particles);

            const grid = new THREE.GridHelper(60, 60, 0x003344, 0x001122);
            grid.rotation.x = Math.PI / 2;
            grid.position.z = -5;
            scene.add(grid);
        }

        // --- ANIMATION LOOP ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (event.clientY - window.innerHeight / 2) * 0.001;
        }

        function onMouseDown() {
            surgeFactor = 5.0;
            const flash = new THREE.PointLight(0xffffff, 5, 100);
            scene.add(flash);
            let intensity = 5;
            const flashInt = setInterval(() => {
                intensity *= 0.8;
                flash.intensity = intensity;
                if(intensity < 0.1) {
                    scene.remove(flash);
                    clearInterval(flashInt);
                }
            }, 50);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            surgeFactor = THREE.MathUtils.lerp(surgeFactor, 1.0, delta * 2.0);

            targetRotationX = mouseY;
            targetRotationY = mouseX;
            engineGroup.rotation.x += 0.05 * (targetRotationX - engineGroup.rotation.x);
            engineGroup.rotation.y += 0.05 * (targetRotationY - engineGroup.rotation.y);
            
            camera.position.z = 25 + Math.sin(time * 0.5) * 1.0;

            const pulse = (Math.sin(time * 1.5) + 1) * 0.5;
            const cColor = new THREE.Color().lerpColors(
                new THREE.Color(CONFIG.colors.cyan), 
                new THREE.Color(CONFIG.colors.purple), 
                pulse
            );
            coreCrystal.material.color = cColor;
            coreCrystal.material.emissiveIntensity = 0.5 + pulse * 1.5 * surgeFactor;
            
            coreCrystal.rotation.y -= 0.005 * surgeFactor;
            coreCrystal.rotation.z += 0.003 * surgeFactor;

            symbols.forEach(mesh => {
                mesh.rotation.z += mesh.userData.rotationSpeed * surgeFactor;
                mesh.position.y += Math.sin(time + mesh.userData.initialPos.x) * 0.005;
            });

            gears.forEach(gear => {
                gear.rotation.z += gear.userData.rotSpeed * surgeFactor;
            });

            satellites.forEach(sat => {
                sat.orbit.rotation.z += sat.orbitSpeed * 0.5 * surgeFactor;
                sat.gear.rotation.z -= 0.03 * surgeFactor;
                sat.gear.userData.innerIco.rotation.x += 0.02 * surgeFactor;
                sat.gear.userData.innerIco.rotation.y += 0.03 * surgeFactor;
            });

            conduits.forEach(c => {
                c.mesh.material.map.offset.x -= c.speed * surgeFactor;
            });

            particles.rotation.y += 0.001 * surgeFactor;

            // Animate Number Sprites
            numberSprites.forEach(sprite => {
                sprite.position.add(sprite.userData.velocity);
                // Pulse opacity
                sprite.material.opacity = 0.4 + Math.sin(time * 2 + sprite.position.x) * 0.2;
                
                // Wrap around logic if they drift too far
                if(sprite.position.length() > 35) {
                    sprite.position.setLength(10);
                }
            });

            composer.render();
        }

        init();

    </script>
</body>
</html>